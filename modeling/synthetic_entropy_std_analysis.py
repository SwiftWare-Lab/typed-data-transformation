import numpy as np
import scipy.stats as stats

import math
from collections import Counter


def generate_byte_stream(size, entropy):
    """
    Generate a byte stream of a given size with a specified entropy.

    Parameters:
    - size (int): The size of the byte stream to generate.
    - entropy (float): The desired entropy (0 to 8, as entropy for bytes is max 8 bits).

    Returns:
    - bytes: A byte stream of the specified size and entropy.
    """
    if entropy < 0 or entropy > 65:
        raise ValueError("Entropy must be between 0 and 8.")

    # Calculate the number of unique byte values needed
    num_symbols = int(2 ** entropy)

    # Create probabilities for the symbols
    probabilities = np.ones(num_symbols) / num_symbols

    # Generate the byte stream
    symbols = np.random.choice(range(num_symbols), size=size, p=probabilities)
    # cast it as int8
    if entropy <= 8:
        symbols = symbols.astype(np.uint8)
    elif entropy <= 16:
        symbols = symbols.astype(np.uint16)
    elif entropy <= 32:
        symbols = symbols.astype(np.uint32)
    elif entropy <= 64:
        symbols = symbols.astype(np.uint64)
    else:
        raise ValueError("Entropy too high for byte stream generation.")
    # random shuffle the symbols
    np.random.shuffle(symbols)
    return symbols


def compute_entropy(stream):
    # Count occurrences of each element
    counts = Counter(stream)
    total = len(stream)
    # Calculate probabilities and entropy
    entropy = 0
    for count in counts.values():
        p = count / total
        entropy -= p * math.log2(p)
    return entropy


def generate_float_stream(size, entropy_per_byte_array):
    num_components = len(entropy_per_byte_array)
    entropy_array = np.zeros(num_components)
    byte_width = 4
    if byte_width > 8:
        raise ValueError("Bit width exceeds 64 bits.")
    byte_array = []

    if num_components == 4:
        packed_array = np.zeros(size * num_components, dtype=np.uint8)
        byte_array.append(generate_byte_stream(size, entropy_per_byte_array[0]))
        byte_array.append(generate_byte_stream(size, entropy_per_byte_array[1]))
        byte_array.append(generate_byte_stream(size, entropy_per_byte_array[2]))
        byte_array.append(generate_byte_stream(size, entropy_per_byte_array[3]))
        for i in range(0, size, num_components):
            packed_array[i] = byte_array[0][i]
            packed_array[i + 1] = byte_array[1][i]
            packed_array[i + 2] = byte_array[2][i]
            packed_array[i + 3] = byte_array[3][i]

    if num_components == 2:
        packed_array = np.zeros(size * num_components, dtype=np.uint16)
        byte_array.append(generate_byte_stream(size, entropy_per_byte_array[0]))
        byte_array.append(generate_byte_stream(size, entropy_per_byte_array[1]))
        #print(f"Entropy of the generated float stream 1 : {compute_entropy(byte_array[0])} \n\n")
        #print(f"Entropy of the generated float stream 2 : {compute_entropy(byte_array[1])} \n\n")
        entropy_array[0] = compute_entropy(byte_array[0])
        entropy_array[1] = compute_entropy(byte_array[1])
        for i in range(0, size, num_components):
            packed_array[i] = byte_array[0][i]
            packed_array[i + 1] = byte_array[1][i]

    if num_components == 1:
        packed_array = np.zeros(size, dtype=np.uint32)
        byte_array.append(generate_byte_stream(size, entropy_per_byte_array[0]))
        entropy_array[0] = compute_entropy(byte_array[0])
        for i in range(0, size, num_components):
            packed_array[i] = byte_array[0][i]
    return packed_array, byte_array, entropy_array


def compress_with_zstd(data, level=3):
    import zstandard as zstd
    cctx = zstd.ZstdCompressor(level=level)
    compressed = cctx.compress(data)
    # comp ratio
    comp_ratio = len(data.tobytes()) / len(compressed)
    return compressed, comp_ratio



# Example usage
# byte_stream = generate_byte_stream(16*1024*1024, 22)  # 1024 bytes with entropy of 4
# print(f"Generated byte stream of size {len(byte_stream)} with entropy .")
#
# # e1 = stats.entropy(byte_stream)
# # print(f"Entropy of the generated byte stream: {e1}")
# print(f"Entropy of the generated byte stream: {compute_entropy(byte_stream)} \n\n")
for i in range(17, 33):
    print(f" -------------- Entropy: {i} --------------")
    float_stream, comp_array, comp_entropy_array = generate_float_stream(2*1024*1024, [i])
    print(f"Generated float stream of size {len(float_stream)} with entropy .")
    print(f"Entropy of the generated float stream: {compute_entropy(float_stream)}")
    # cast it as int32
    float_stream_i32 = float_stream.view(dtype=np.uint32)
    print(f"Entropy of the generated float stream: {compute_entropy(float_stream_i32)}")
    # compress the data
    comp, comp_ratio = compress_with_zstd(float_stream)
    print(f"CR: {comp_ratio}")
    # make each a component
    byte_array = float_stream_i32.view(dtype=np.uint8)
    comp_array = []
    comp_array.append(byte_array[0: len(byte_array) : 4])
    comp_array.append(byte_array[1: len(byte_array) : 4])
    comp_array.append(byte_array[2: len(byte_array) : 4])
    comp_array.append(byte_array[3: len(byte_array) : 4])
    comp_array_np = []
    comp_array_np.append(np.array(comp_array[0]))
    comp_array_np.append(np.array(comp_array[1]))
    comp_array_np.append(np.array(comp_array[2]))
    comp_array_np.append(np.array(comp_array[3]))

    # compress each component
    decomposed_size = 0
    for c in comp_array_np:
        decompressed, comp_ratio = compress_with_zstd(c)
        decomposed_size += len(decompressed)
        print(f"entropy of: {compute_entropy(c)}")
    decomp_cr = len(float_stream.tobytes()) / decomposed_size
    print(f"-> CR dec: {decomp_cr} \n\n\n")


exit(1)

for i in range(1, 8):
    float_stream, comp_array, comp_entropy_array = generate_float_stream(16*1024*1024, [7, 7, i, 8-i])
    # print(f"Generated float stream of size {len(float_stream)} with entropy .")
    # print(f"Entropy of the generated float stream: {compute_entropy(float_stream)} \n\n")
    decomposed_size = 0
    for c in comp_array:
        decompressed, comp_ratio = compress_with_zstd(c)
        decomposed_size += len(decompressed)
    decomp_cr = len(float_stream.tobytes()) / decomposed_size
    orig_cop, original_cr = compress_with_zstd(float_stream)
    entropy_bytes = compute_entropy(float_stream)
    # cast it as int32
    float_stream_i32 = float_stream.view(dtype=np.uint32)
    orig_cop32, original_cr32 = compress_with_zstd(float_stream_i32)
    print(f"Entropy-8: {entropy_bytes}  Entropy-32: {compute_entropy(float_stream_i32)} \n\n")
    print(f"CR decomp:  {decomp_cr}, original: {original_cr}, original32:{original_cr32} \n\n")

